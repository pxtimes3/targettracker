// Generated by Qodo Gen

import type { Point } from '@/types/editor';
import { Geometry } from '@/utils/geometry';
import { describe, it, expect, vi, beforeEach } from 'vitest';

type Points = {x: number, y: number}[]


describe('findMinCircle', () => {
    // Handles points with negative coordinates
    it('should handle points with negative coordinates correctly', () => {
      // Arrange
      const circleCalculator = {
        findMinCircle: function(points: Points ) {
          if (points.length === 0) return { center: {x: 0, y: 0}, radius: 0 };
          if (points.length === 1) return { center: points[0], radius: 0 };
          if (points.length === 2) return this.makeCircleFromTwoPoints(points[0], points[1]);
  
          // Find the two points furthest from each other
          let maxDist = 0;
          let point1 = points[0];
          let point2 = points[0];
  
          for (let i = 0; i < points.length; i++) {
              for (let j = i + 1; j < points.length; j++) {
                  const dist = Math.sqrt(
                      Math.pow(points[i].x - points[j].x, 2) + 
                      Math.pow(points[i].y - points[j].y, 2)
                  );
                  if (dist > maxDist) {
                      maxDist = dist;
                      point1 = points[i];
                      point2 = points[j];
                  }
              }
          }
  
          // Center is halfway between furthest points
          const center = {
              x: (point1.x + point2.x) / 2,
              y: (point1.y + point2.y) / 2
          };
  
          // Radius is half the distance between furthest points
          const radius = maxDist / 2;
  
          return { center, radius };
        },
        makeCircleFromTwoPoints: function(p1: {x: number, y: number}, p2: {x: number, y: number}) 
        {
          const centerX = (p1.x + p2.x) / 2;
          const centerY = (p1.y + p2.y) / 2;
          const radius = Math.sqrt(
            Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)
          ) / 2;
          return { center: { x: centerX, y: centerY }, radius };
        }
      };
  
      // Act
      const points = [
        { x: -5, y: -10 },
        { x: 5, y: -5 },
        { x: -3, y: 8 }
      ];
      const result = circleCalculator.findMinCircle(points);
  
      // Assert
      // The furthest points should be { x: -5, y: -10 } and { x: -3, y: 8 }
      // Distance between them is sqrt((-5-(-3))^2 + (-10-8)^2) = sqrt(4 + 324) = sqrt(328) ≈ 18.11
      // Center should be at { x: (-5+(-3))/2, y: (-10+8)/2 } = { x: -4, y: -1 }
      // Radius should be 18.11/2 ≈ 9.055
      expect(result.center.x).toBeCloseTo(-4);
      expect(result.center.y).toBeCloseTo(-1);
      expect(result.radius).toBeCloseTo(9.055, 1);
    });

    // Returns a circle with center at origin and radius 0 for empty array
    it('should return circle with center at origin and radius 0 when points array is empty', () => {
        // Arrange
        const instance = new Geometry();

        // Act
        const result = instance.findMinCircle([]);

        // Assert
        expect(result).toEqual({ center: { x: 0, y: 0 }, radius: 0 });
    });

    // Returns a circle with center at the point and radius 0 for single point
    it('should return a circle with center at the point and radius 0 when given a single point', () => {
        // Arrange
        const points = [{ x: 5, y: 10 }];
        const expectedCircle = { center: { x: 5, y: 10 }, radius: 0 };
        const instance = new Geometry(); // Correct class name

        // Act
        const result = instance.findMinCircle(points);

        // Assert
        expect(result).toEqual(expectedCircle);
    });

    // Correctly calculates the center as midpoint between furthest points
    it('should calculate the center as midpoint between the two furthest points', () => {
        // Arrange
        const points = [
            { x: 0, y: 0 },
            { x: 4, y: 0 },
            { x: 2, y: 3 }
        ];
        const expectedCenter = { x: 2, y: 0 };
        const expectedRadius = 2;

        // Act
        const result = new Geometry().findMinCircle(points);

        // Assert
        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius);
    });

    // Correctly calculates the radius as half the distance between furthest points
    it('should calculate the correct radius for two furthest points', () => {
        const points = [
            { x: 0, y: 0 },
            { x: 0, y: 4 },
            { x: 3, y: 0 }
        ];
        const expectedRadius = 2.5; // Half of the distance between (0,4) and (3,0)
        const circle = new Geometry().findMinCircle(points);
        expect(circle.radius).toBeCloseTo(expectedRadius, 5);
    });

    // Returns a circle with center midway between points for two points
    it('should return a circle with center midway between two points when given two points', () => {
        // Arrange
        const points = [{ x: 0, y: 0 }, { x: 4, y: 0 }];
        const expectedCenter = { x: 2, y: 0 };
        const expectedRadius = 2;
        const instance = new Geometry(); // Correct class name

        // Act
        const result = instance.findMinCircle(points);

        // Assert
        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBe(expectedRadius);
    });

    // Finds the two furthest points and creates a circle for three or more points
    it('should find the two furthest points and create a circle for three or more points', () => {
        // Arrange
        const points = [
            { x: 0, y: 0 },
            { x: 0, y: 3 },
            { x: 4, y: 0 }
        ];
        const expectedCenter = { x: 2, y: 1.5 };
        const expectedRadius = 2.5;
        const instance = new Geometry(); // Correct class name

        // Act
        const result = instance.findMinCircle(points);

        // Assert
        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius, 5);
    });

    // Ensures the method correctly calculates the minimum enclosing circle for points arranged in a circle
    it('should find the minimum enclosing circle for points arranged in a circle', () => {
        const points = [
            { x: 1, y: 0 },
            { x: 0, y: 1 },
            { x: -1, y: 0 },
            { x: 0, y: -1 }
        ];
        const expectedCenter = { x: 0, y: 0 };
        const expectedRadius = 1;

        const result = new Geometry().findMinCircle(points);

        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius, 5);
    });

    // May not find optimal minimum enclosing circle for certain point configurations
    it('should not find optimal circle for three collinear points', () => {
        const points = [{x: 0, y: 0}, {x: 2, y: 0}, {x: 4, y: 0}];
        const expectedCenter = {x: 2, y: 0};
        const expectedRadius = 2;

        const result = new Geometry().findMinCircle(points);

        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius);
    });

    // Performance degrades quadratically with number of points (O(n²) complexity)
    it('should exhibit quadratic performance degradation with increasing points', () => {
        const instance = new Geometry(); // Correct class instantiation
        const points = [];
        const numPoints = 1000; // Adjust the number of points for testing

        for (let i = 0; i < numPoints; i++) {
            points.push({ x: Math.random() * 1000, y: Math.random() * 1000 });
        }

        const startTime = performance.now();
        instance.findMinCircle(points);
        const endTime = performance.now();

        console.log(`Execution time for ${numPoints} points: ${endTime - startTime} ms`);
        // You can add assertions based on expected performance characteristics
    });

    // Verify that the findMinCircle method correctly calculates the center and radius for two given points.
    it('should return correct center and radius for two points', () => {
        // Arrange
        const points = [{ x: 0, y: 0 }, { x: 4, y: 0 }];
        const expectedCenter = { x: 2, y: 0 };
        const expectedRadius = 2;
        const instance = new Geometry(); // Correct class name

        // Act
        const result = instance.findMinCircle(points);

        // Assert
        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius);
    });

    // Relies on makeCircleFromTwoPoints method for the two-point case
    it('should call makeCircleFromTwoPoints when there are exactly two points', () => {
        // Arrange
        const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];
        const mockMakeCircleFromTwoPoints = vi.fn().mockReturnValue({ center: { x: 2, y: 3 }, radius: 1 });
        const instance = {
            makeCircleFromTwoPoints: mockMakeCircleFromTwoPoints,
            findMinCircle: function(points: Points) {
                if (points.length === 2) return this.makeCircleFromTwoPoints(points[0], points[1]);
            }
        };

        // Act
        const result = instance.findMinCircle(points);

        // Assert
        expect(mockMakeCircleFromTwoPoints).toHaveBeenCalledWith(points[0], points[1]);
        expect(result).toEqual({ center: { x: 2, y: 3 }, radius: 1 });
    });

    // Handles array with duplicate points
    it('should return correct circle when array contains duplicate points', () => {
        const points = [
            { x: 1, y: 1 },
            { x: 1, y: 1 },
            { x: 2, y: 2 },
            { x: 3, y: 3 }
        ];
        const expectedCircle = {
            center: { x: 2, y: 2 },
            radius: Math.sqrt(2)
        };
        const result = new Geometry().findMinCircle(points);
        expect(result.center).toEqual(expectedCircle.center);
        expect(result.radius).toBeCloseTo(expectedCircle.radius);
    });

    // Handles points with very large coordinate values
    it('should correctly calculate the circle for points with large coordinates', () => {
        const points = [
            { x: 1e9, y: 1e9 },
            { x: -1e9, y: -1e9 },
            { x: 1e9, y: -1e9 },
            { x: -1e9, y: 1e9 }
        ];
        const expectedCenter = { x: 0, y: 0 };
        const expectedRadius = Math.sqrt(2) * 1e9;

        const result = new Geometry().findMinCircle(points);

        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius, 5);
    });

    // Handles points with decimal/floating point coordinates
    it('should correctly calculate the minimum circle for points with decimal coordinates', () => {
      const points = [
        { x: 1.5, y: 2.5 },
        { x: 3.5, y: 4.5 },
        { x: 5.5, y: 6.5 }
      ];
      const expectedCenter = { x: 3.5, y: 4.5 };
      const expectedRadius = Math.sqrt(8);

      const result = new Geometry().findMinCircle(points);

      expect(result.center).toEqual(expectedCenter);
      expect(result.radius).toBeCloseTo(expectedRadius, 5);
    });

    // Handles collinear points (points in a straight line)
    it('should return correct circle for collinear points', () => {
        const points = [
            { x: 0, y: 0 },
            { x: 2, y: 0 },
            { x: 4, y: 0 }
        ];
        const expectedCenter = { x: 2, y: 0 };
        const expectedRadius = 2;

        const result = new Geometry().findMinCircle(points);

        expect(result.center).toEqual(expectedCenter);
        expect(result.radius).toBeCloseTo(expectedRadius);
    });
});
